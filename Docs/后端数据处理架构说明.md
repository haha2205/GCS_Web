# Apollo-GCS Web 后端数据处理架构说明

## 概述

后端数据处理架构采用**双流向（Dual-Stream）设计**，将UDP数据流分为两个独立但并行的处理分支：
- **热流（Hot Stream）**：实时计算，为前端提供5维KPI监控数据
- **冷流（Cold Stream）**：全量录制，用于DSM离线分析和架构优化

![数据处理架构图](image.png)

---

## 一、架构设计原则

### 1.1 双流并发处理

```
UDP接收 → [数据复制] → Hot Stream + Cold Stream
                     ↓              ↓
                实时计算引擎      数据录制器
                     ↓              ↓
              KPI广播(20Hz)    CSV文件存储
```

### 1.2 解耦设计

- **实时监控**与**DSM分析**完全解耦
- 实时监控关注瞬时性能指标
- DSM分析关注统计聚合数据
- 互不干扰，各司其职

### 1.3 模块化架构

每个功能模块职责清晰：
- `recorder/`：数据录制器
- `calculator/`：实时计算引擎
- `dsm/`：DSM数据生成器
- `config/`：映射配置管理

---

## 二、核心模块详解

### 2.1 数据录制器模块 (`recorder/`)

#### 功能定位
将UDP原始数据按类型分文件存储到CSV，为DSM离线分析提供数据源。

#### 核心类：`RawDataRecorder`

**主要特性：**
1. 按数据类型分文件存储：
   - `flight_perf.csv`：飞行性能数据（位置、姿态、速度）
   - `resources.csv`：资源数据（CPU负载、内存使用）
   - `bus_traffic.csv`：总线通信数据（消息ID、大小、频率）
   - `obstacles.csv`：障碍物数据（位置、尺寸、置信度）

2. 高效写入机制：
   - 文件句柄复用，避免频繁打开/关闭
   - 每100行自动刷新缓冲区
   - 使用CSV格式，Pandas直接读取

3. 会话管理：
   - 每次录制生成独立会话目录：`data/{session_id}/`
   - 支持时间切片过滤
   - 统计数据行数和记录计数

**使用方式：**

```python
from recorder import RawDataRecorder

# 创建录制器
recorder = RawDataRecorder("session_20260119")

# 开始录制
recorder.start_recording()

# 记录数据
recorder.record_decoded_packet(decoded_udp_packet)

# 停止录制
recorder.stop_recording()

# 获取会话信息
info = recorder.get_session_info()
print(f"录制时长: {info['duration']}秒")
print(f"数据统计: {info['data_counters']}")
```

### 2.2 实时计算引擎模块 (`calculator/`)

#### 功能定位
提供5维KPI指标实时计算，支持前端多维度监控面板。

#### 核心类：`RealTimeCalculator`

**5个维度KPI：**

1. **算力资源（Computing）**：
   - 实时CPU负载监控
   - CPU负载平均值计算
   - 基于阈值的评分（90%为临界值）
   - 状态判断：normal / high

2. **通信资源（Communication）**：
   - 抖动计算（基于消息到达时间间隔）
   - 丢包率计算（基于序列号跳变）
   - 滑动窗口统计（最近100个包）
   - 综合评分（丢包率权重70%，抖动权重30%）

3. **能耗指标（Energy）**：
   - 瞬时功率计算（电压 × 电流）
   - 累计能耗积分（焦耳）
   - 功率平滑显示（最近50次读数平均值）
   - 能耗等级评分

4. **任务效能（Mission）**：
   - 任务覆盖率（完成航点/总航点）
   - 安全余量（电量余量 - 返航所需）
   - 综合评分（进度60% + 安全余量40%）

5. **飞行性能（Performance）**：
   - 位置误差RMSE（欧氏距离）
   - 姿态稳定性（基于roll和pitch）
   - 轨迹误差平滑（最近50个点）
   - 等级判定：excellent / good / fair / poor

**使用方式：**

```python
from calculator import RealTimeCalculator

# 创建计算引擎
calculator = RealTimeCalculator()

# 处理UDP数据包
kpi_result = calculator.process_packet(decoded_udp_packet)

# 获取KPI结果
overall_score = kpi_result['overall_score']
computing_score = kpi_result['dimensions']['computing']['score']
comm_score = kpi_result['dimensions']['communication']['score']

# 广播到前端
await manager.broadcast({
    'type': 'kpi_update',
    'data': kpi_result
})
```

### 2.3 映射配置管理模块 (`config/`)

#### 功能定位
定义物理数据与逻辑架构的对应关系，作为DSM数据转换的"桥接器"。

#### 核心类：`MappingConfig`

**配置文件结构（YAML）：**

```yaml
version: '1.0'
description: '物理数据到逻辑架构的映射配置'

# 节点映射（计算DSM对角线）
nodes:
  - logical_function: 'LF_Navigation'
    physical_source:
      type: 'cpu_load'
      filter_id: 0x42
      metric: 'avg_load'
      description: '导航任务'
  # ... 更多节点

# 交互映射（计算DSM非对角线）
edges:
  - functional_exchange: 'FE_Nav_State'
    source_lf: 'LF_Navigation'
    target_lf: 'LF_Flight_Controller'
    physical_source:
      type: 'bus_traffic'
      filter_id: 0x42
      weight_formula: 'frequency * size'
      description: '导航状态传输'
  # ... 更多边
```

**主要功能：**

1. **配置加载与验证**：
   - 自动创建默认配置（首次运行时）
   - YAML格式验证
   - 必需字段检查

2. **查询接口**：
   - `get_nodes()`：获取所有节点映射
   - `get_edges()`：获取所有边映射
   - `get_node_by_lf_name()`：根据逻辑功能名查询
   - `get_edges_by_source()/target()`：查询交互关系

3. **权重公式计算**：
   - 支持动态公式（如 `frequency * size`）
   - 安全的公式评估（防止代码注入）
   - 变量替换机制

**使用方式：**

```python
from config import MappingConfig

# 加载配置
mapping_config = MappingConfig("config/mapping_config.yaml")

# 获取节点映射
nodes = mapping_config.get_nodes()
for node in nodes:
    print(f"逻辑功能: {node['logical_function']}")
    print(f"物理来源: {node['physical_source']}")

# 获取边映射
edges = mapping_config.get_edges()
for edge in edges:
    weight_formula = edge['physical_source']['weight_formula']
    print(f"边 {edge['from']} -> {edge['to']} 采用公式: {weight_formula}")

# 重新加载配置（修改YAML文件后）
mapping_config.reload()
```

### 2.4 DSM数据生成器模块 (`dsm/`)

#### 功能定位
离线处理录制数据，生成DSM算法所需的标准格式文件（JSON/CSV矩阵）。

#### 核心类：`DSMGenerator`

**处理流程：**

```
1. 加载原始数据
   ├─ 读取 flight_perf.csv
   ├─ 读取 resources.csv
   └─ 读取 bus_traffic.csv

2. 时间切片（可选）
   └─ [start_time, end_time] 范围过滤

3. 计算节点权重（对角线）
   ├─ 根据 filter_id 筛选物理数据
   ├─ 计算 metric (avg_load / peak_load)
   └─ 生成节点列表

4. 计算交互权重（非对角线）
   ├─ 根据 msg_id 筛选通信数据
   ├─ 计算 weight_formula
   └─ 生成边列表

5. 构建DSM矩阵
   ├─ 填充对角线：节点自身代价
   └─ 填充非对角线：交互强度

6. 输出结果
   ├─ JSON格式（完整元数据）
   └─ CSV矩阵格式（MATLAB/Numpy直接读取）
```

**输出格式：**

**格式1：JSON（推荐）**
```json
{
  "meta": {
    "session_id": "20260119_test01",
    "generated_at": "2026-01-19T05:00:00",
    "time_range": {
      "start": 1705660800.0,
      "end": 1705660860.0,
      "duration": 60.0
    },
    "data_statistics": {
      "flight_records": 3000,
      "resource_records": 1500,
      "bus_records": 6000
    }
  },
  "nodes": [
    {
      "index": 0,
      "name": "LF_Navigation",
      "own_cost": 25.35,
      "attributes": {
        "description": "导航任务",
        "filter_id": 66,
        "metric_type": "avg_load",
        "safety_level": "DAL-B"
      }
    }
  ],
  "edges": [
    {
      "from": "LF_Navigation",
      "to": "LF_Flight_Controller",
      "weight": 12500.0,
      "type": "DataFlow",
      "functional_exchange": "FE_Nav_State_Trasmission"
    }
  ],
  "matrix": [
    [25.35, 12500.0, 0, 0, 0],
    [0, 20.15, 0, 0, 0],
    [0, 0, 80.25, 0, 0],
    [0, 0, 0, 15.80, 0],
    [0, 0, 0, 0, 30.60]
  ]
}
```

**格式2：CSV矩阵（MATLAB友好）**
```csv
,LF_Nav,LF_Motor,LF_FCtrl,LF_Avoid,LF_Fusion
LF_Nav,25.35,12500.0,0,0,0
LF_Motor,0,20.15,0,0,0
LF_FCtrl,0,0,80.25,0,0
LF_Avoid,0,0,0,15.80,0
LF_Fusion,0,0,0,0,30.60
```

**使用方式：**

```python
from dsm import DSMGenerator
from config import MappingConfig

# 加载映射配置
mapping_config = MappingConfig()

# 创建DSM生成器
dsm_generator = DSMGenerator(mapping_config)

# 生成DSM报告
report = dsm_generator.generate_dsm_report(
    session_id="20260119_test01",
    base_directory="data",
    start_time=1705660800.0,  # 可选
    end_time=1705660860.0,    # 可选
    output_format="json"
)

# 获取结果
output_path = report['output_path']
matrix = report['matrix']
nodes = report['nodes']
edges = report['edges']

# 导出MATLAB格式
dsm_generator.export_for_matlab(report, "output/dsm_data.mat")
```

---

## 三、API端点说明

### 3.1 录制控制API

#### `GET /api/recording/status`
获取当前录制状态。

**响应：**
```json
{
  "type": "recording_status",
  "is_active": true,
  "session_id": "20260119_053000",
  "session_info": {
    "session_id": "20260119_053000",
    "is_recording": true,
    "start_time": 1705660800.0,
    "end_time": null,
    "duration": 0,
    "data_directory": "data/20260119_053000",
    "data_counters": {
      "flight_perf": 1234,
      "resources": 567,
      "bus_traffic": 2345
    }
  }
}
```

#### `POST /api/recording/start`
开始数据录制。

**请求体：**
```json
{
  "session_id": "session_20260119",
  "auto_start": false,
  "base_directory": "data"
}
```

**响应：**
```json
{
  "type": "recording_response",
  "status": "success",
  "message": "录制已开始",
  "session_id": "session_20260119",
  "timestamp": 1705660800000
}
```

#### `POST /api/recording/stop`
停止数据录制。

**响应：**
```json
{
  "type": "recording_response",
  "status": "success",
  "message": "录制已停止",
  "session_id": "session_20260119",
  "session_info": { ... },
  "timestamp": 1705660860000
}
```

#### `GET /api/recording/sessions`
列出所有录制会话。

**查询参数：**
- `base_directory`: 数据基目录（默认：data）

**响应：**
```json
{
  "type": "sessions_list",
  "sessions": [
    {
      "session_id": "20260119_053000",
      "file_count": 4,
      "path": "data/20260119_053000"
    }
  ],
  "timestamp": 1705660900000
}
```

### 3.2 DSM报告生成API

#### `POST /api/dsm/generate`
生成DSM分析报告。

**请求体：**
```json
{
  "session_id": "20260119_test01",
  "base_directory": "data",
  "start_time": 1705660800.0,
  "end_time": 1705660860.0,
  "output_format": "json"
}
```

**响应：**
```json
{
  "type": "dsm_report_response",
  "status": "success",
  "message": "DSM报告生成成功",
  "report": { ... },
  "timestamp": 1705660900000
}
```

#### `GET /api/dsm/config`
获取DSM映射配置。

**响应：**
```json
{
  "type": "dsm_config",
  "config": { ... },
  "timestamp": 1705660900000
}
```

#### `POST /api/dsm/config`
更新DSM映射配置。

**请求体：**
```json
{
  "version": "1.0",
  "nodes": [ ... ],
  "edges": [ ... ],
  "metadata": { ... }
}
```

**响应：**
```json
{
  "type": "dsm_config_response",
  "status": "success",
  "message": "DSM映射配置已更新",
  "timestamp": 1705660900000
}
```

#### `GET /api/dsm/export/{session_id}`
下载DSM报告文件。

**查询参数：**
- `format`: 输出格式（json/csv_matrix）

**响应：** 文件下载

---

## 四、完整数据流程示例

### 场景：无人机避障飞行任务DSM分析

#### 第一阶段：在线录制

1. **前端点击"开始录制"**
   - 调用：`POST /api/recording/start`
   - 后端创建录制器，打开CSV文件句柄

2. **无人机执行避障任务**
   - UDP接收飞行状态数据（50Hz）
   - Hot Stream：实时计算KPI，广播20Hz到前端
   - Cold Stream：并行写入CSV文件
   - 原始数据也被WebSocket广播（用于实时监控）

3. **任务完成，停止录制**
   - 调用：`POST /api/recording/stop`
   - 后端关闭文件句柄，统计录制时长和数据量
   - 结果：
     ```
     session_id: "20260119_obstacle_avoidance"
     duration: 120.5秒
     flight_perf: 6025条
     resources: 2410条
     bus_traffic: 12050条
     ```

#### 第二阶段：离线处理

4. **前端选择录制会话**
   - 调用：`GET /api/recording/sessions`
   - 显示所有录制会话列表

5. **生成DSM报告**
   - 调用：`POST /api/dsm/generate`
   - 参数：
     ```json
     {
       "session_id": "20260119_obstacle_avoidance",
       "output_format": "json"
     }
     ```
   
6. **后端处理流程**
   - 读取CSV文件：`flight_perf.csv`, `resources.csv`, `bus_traffic.csv`
   - 根据 `mapping_config.yaml` 聚合数据：
     - 节点权重：
       ```python
       LF_Navigation -> CPU平均负载 = 45.2%
       LF_Motor_Control -> CPU峰值负载 = 85.3%
       ```
     - 交互权重：
       ```python
       LF_Navigation -> LF_Flight_Controller
       = frequency(50Hz) × size(100字节) = 5000
       ```
   - 构建DSM矩阵（6x6矩阵）
   - 生成 `dsm_report_20260119_054500.json`

7. **下载报告**
   - 调用：`GET /api/dsm/export/20260119_obstacle_avoidance`
   - 前端下载JSON或CSV矩阵文件
   - 导入MATLAB/Python进行DSM聚类优化

#### 第三阶段：架构优化

8. **DSM算法分析**
   - 读取 `dsm_data.mat`
   - 应用聚类算法（如K-means、层次聚类）
   - 识别高耦合模块
   - 生成优化建议

9. **迭代优化**
   - 更新Capella架构模型
   - 修改逻辑功能分配
   - 重新录制新任务
   - 再次生成DSM报告
   - 对比优化前后的性能指标

---

## 五、性能优化与最佳实践

### 5.1 数据写入优化

- **批量写入**：每100行刷新一次缓冲区
- **文件句柄复用**：避免频繁打开/关闭
- **异步I/O**：`aiofiles`库支持（可选）

### 5.2 内存管理

- **滑动窗口**：KPI计算使用固定大小窗口（如50个样本）
- **及时释放**：录制停止时立即关闭文件句柄
- **数据切片**：支持时间范围查询，避免全量加载

### 5.3 并发安全

- **线程安全**：文件写入使用锁保护（如需多线程录制）
- **WebSocket广播**：异步任务，不阻塞UDP接收
- **配置热重载**：支持运行时更新映射配置

### 5.4 错误处理

- **优雅降级**：数据解析失败时记录错误，继续处理后续包
- **日志记录**：所有关键操作都有详细日志
- **状态检查**：API调用前验证系统状态

---

## 六、扩展功能展望

### 6.1 实时DSM分析

- 基于滑动窗口的实时DSM矩阵更新
- WebSocket推送实时DSM热图
- 前端实时优化建议展示

### 6.2 多模态数据融合

- 视频流录制（避障摄像头）
- 音频数据录制（噪声监测）
- 多传感器数据对齐（时间戳同步）

### 6.3 云端协同分析

- 录制数据自动上传云端
- 分布式DSM计算
- 多无人机集群架构优化

### 6.4 AI辅助架构优化

- 基于机器学习的DSM聚类推荐
- 自动识别架构瓶颈
- 预测系统性能趋势

---

## 七、故障排查指南

### 问题1：录制文件为空
**原因**：录制未启动或UDP未接收数据
**解决**：
- 检查录制状态：`GET /api/recording/status`
- 检查UDP连接：查看日志 `[UDP] 飞行状态` 消息
- 验证端口配置：`GET /api/config/connection`

### 问题2：DSM报告生成失败
**原因**：CSV文件损坏或映射配置错误
**解决**：
- 检查CSV文件格式：使用文本编辑器打开验证
- 检查映射配置：`GET /api/dsm/config`
- 查看后端日志：`gcs_backend.log` 中的详细错误信息

### 问题3：KPI数据不准确
**原因**：计算参数需要调整
**解决**：
- 修改 `RealTimeCalculator` 中的阈值（如90% CPU临界值）
- 调整滑动窗口大小（从50改为100）
- 重新启动后端服务

---

## 八、总结

本后端数据处理架构实现了：

✅ **双流并发处理**：实时监控 + 离线分析互不干扰
✅ **模块化设计**：每个功能模块职责清晰，易于维护
✅ **灵活配置**：YAML映射配置，无需修改代码即可适应新架构
✅ **可扩展性**：支持多种输出格式，易于集成第三方工具
✅ **高性能**：异步I/O、批量写入、滑动窗口优化

该架构完美契合eVTOL项目对"实时监控"和"架构优化"的双重需求，为后续的DSM算法研究提供了坚实的基础数据平台。